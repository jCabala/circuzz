#include <stdio.h>
#include <iostream>
#include <assert.h>
#include "circom.hpp"
#include "calcwit.hpp"
#include "fr.hpp"
void MultiMux1_0_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void MultiMux1_0_run(uint ctx_index,Circom_CalcWit* ctx);
void Mux1_1_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void Mux1_1_run(uint ctx_index,Circom_CalcWit* ctx);
void Num2Bits_2_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void Num2Bits_2_run(uint ctx_index,Circom_CalcWit* ctx);
void LessThan_3_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void LessThan_3_run(uint ctx_index,Circom_CalcWit* ctx);
void LessEqThan_4_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void LessEqThan_4_run(uint ctx_index,Circom_CalcWit* ctx);
void NOT_5_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void NOT_5_run(uint ctx_index,Circom_CalcWit* ctx);
void XOR_6_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void XOR_6_run(uint ctx_index,Circom_CalcWit* ctx);
void IsZero_7_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void IsZero_7_run(uint ctx_index,Circom_CalcWit* ctx);
void IsEqual_8_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void IsEqual_8_run(uint ctx_index,Circom_CalcWit* ctx);
void GreaterThan_9_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void GreaterThan_9_run(uint ctx_index,Circom_CalcWit* ctx);
void OR_10_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void OR_10_run(uint ctx_index,Circom_CalcWit* ctx);
void AND_11_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void AND_11_run(uint ctx_index,Circom_CalcWit* ctx);
void main_template_12_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather);
void main_template_12_run(uint ctx_index,Circom_CalcWit* ctx);
Circom_TemplateFunction _functionTable[13] = { 
MultiMux1_0_run,
Mux1_1_run,
Num2Bits_2_run,
LessThan_3_run,
LessEqThan_4_run,
NOT_5_run,
XOR_6_run,
IsZero_7_run,
IsEqual_8_run,
GreaterThan_9_run,
OR_10_run,
AND_11_run,
main_template_12_run };
Circom_TemplateFunction _functionTableParallel[13] = { 
NULL,
NULL,
NULL,
NULL,
NULL,
NULL,
NULL,
NULL,
NULL,
NULL,
NULL,
NULL,
NULL };
uint get_main_input_signal_start() {return 3;}

uint get_main_input_signal_no() {return 2;}

uint get_total_signal_no() {return 940;}

uint get_number_of_components() {return 50;}

uint get_size_of_input_hashmap() {return 256;}

uint get_size_of_witness() {return 802;}

uint get_size_of_constants() {return 11;}

uint get_size_of_io_map() {return 0;}

uint get_size_of_bus_field_map() {return 0;}

void release_memory_component(Circom_CalcWit* ctx, uint pos) {{

if (pos != 0){{

if(ctx->componentMemory[pos].subcomponents)
delete []ctx->componentMemory[pos].subcomponents;

if(ctx->componentMemory[pos].subcomponentsParallel)
delete []ctx->componentMemory[pos].subcomponentsParallel;

if(ctx->componentMemory[pos].outputIsSet)
delete []ctx->componentMemory[pos].outputIsSet;

if(ctx->componentMemory[pos].mutexes)
delete []ctx->componentMemory[pos].mutexes;

if(ctx->componentMemory[pos].cvs)
delete []ctx->componentMemory[pos].cvs;

if(ctx->componentMemory[pos].sbct)
delete []ctx->componentMemory[pos].sbct;

}}


}}


// function declarations
// template declarations
void MultiMux1_0_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 0;
ctx->componentMemory[coffset].templateName = "MultiMux1";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 3;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[0];
}

void MultiMux1_0_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[3];
u64 lvar[2];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
// load src
// end load src
lvar[0] = 1ull;
// load src
// end load src
lvar[1] = 0ull;
while(Fr_isTrue(Fr_lt(lvar[1],1ull))){
// load src
// end load src
signalValues[mySignalStart + 0] = Fr_add(Fr_mul(Fr_sub(signalValues[mySignalStart + 2],signalValues[mySignalStart + 1]),signalValues[mySignalStart + 3]),signalValues[mySignalStart + 1]);
// load src
// end load src
lvar[1] = 1ull;
}
for (uint i = 0; i < 0; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void Mux1_1_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 1;
ctx->componentMemory[coffset].templateName = "Mux1";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 3;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[1]{0};
}

void Mux1_1_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[2];
u64 lvar[1];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
{
std::string new_cmp_name = "mux";
MultiMux1_0_create(mySignalStart+4,0+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[0] = 0+ctx_index+1;
}
// load src
// end load src
lvar[0] = 0ull;
// load src
// end load src
lvar[0] = 0ull;
while(Fr_isTrue(Fr_lt(lvar[0],2ull))){
{
uint cmp_index_ref = 0;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + ((0 + (1 * Fr_toInt(lvar[0]))) + 1)] = signalValues[mySignalStart + ((1 * Fr_toInt(lvar[0])) + 1)];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
// load src
// end load src
lvar[0] = Fr_add(lvar[0],1ull);
}
{
uint cmp_index_ref = 0;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = signalValues[mySignalStart + 3];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
MultiMux1_0_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
cmp_index_ref_load = 0;
cmp_index_ref_load = 0;
// end load src
signalValues[mySignalStart + 0] = ctx->signalValues[ctx->componentMemory[mySubcomponents[0]].signalStart + 0];
for (uint i = 0; i < 1; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void Num2Bits_2_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 2;
ctx->componentMemory[coffset].templateName = "Num2Bits";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 1;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[0];
}

void Num2Bits_2_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[4];
u64 lvar[4];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
// load src
// end load src
lvar[0] = 253ull;
// load src
// end load src
lvar[1] = 0ull;
// load src
// end load src
lvar[2] = 1ull;
// load src
// end load src
lvar[3] = 0ull;
while(Fr_isTrue(Fr_lt(lvar[3],253ull))){
// load src
// end load src
signalValues[mySignalStart + ((1 * Fr_toInt(lvar[3])) + 0)] = Fr_band(Fr_shr(signalValues[mySignalStart + 253],lvar[3]),1ull);
{
if (!Fr_isTrue(Fr_eq(Fr_mul(signalValues[mySignalStart + ((1 * Fr_toInt(lvar[3])) + 0)],Fr_sub(signalValues[mySignalStart + ((1 * Fr_toInt(lvar[3])) + 0)],1ull)),0ull))) std::cout << "Failed assert in template/function " << myTemplateName << " line 33. " <<  "Followed trace of components: " << ctx->getTrace(myId) << std::endl;
assert(Fr_isTrue(Fr_eq(Fr_mul(signalValues[mySignalStart + ((1 * Fr_toInt(lvar[3])) + 0)],Fr_sub(signalValues[mySignalStart + ((1 * Fr_toInt(lvar[3])) + 0)],1ull)),0ull)));
}
// load src
// end load src
lvar[1] = Fr_add(lvar[1],Fr_mul(signalValues[mySignalStart + ((1 * Fr_toInt(lvar[3])) + 0)],lvar[2]));
// load src
// end load src
lvar[2] = Fr_add(lvar[2],lvar[2]);
// load src
// end load src
lvar[3] = Fr_add(lvar[3],1ull);
}
{
if (!Fr_isTrue(Fr_eq(lvar[1],signalValues[mySignalStart + 253]))) std::cout << "Failed assert in template/function " << myTemplateName << " line 38. " <<  "Followed trace of components: " << ctx->getTrace(myId) << std::endl;
assert(Fr_isTrue(Fr_eq(lvar[1],signalValues[mySignalStart + 253])));
}
for (uint i = 0; i < 0; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void LessThan_3_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 3;
ctx->componentMemory[coffset].templateName = "LessThan";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 2;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[1]{0};
}

void LessThan_3_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[3];
u64 lvar[1];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
// load src
// end load src
lvar[0] = 252ull;
{
std::string new_cmp_name = "n2b";
Num2Bits_2_create(mySignalStart+3,0+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[0] = 0+ctx_index+1;
}
{
if (!Fr_isTrue(1ull)) std::cout << "Failed assert in template/function " << myTemplateName << " line 90. " <<  "Followed trace of components: " << ctx->getTrace(myId) << std::endl;
assert(Fr_isTrue(1ull));
}
{
uint cmp_index_ref = 0;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 253] = Fr_sub(Fr_add(signalValues[mySignalStart + 1],0ull),signalValues[mySignalStart + 2]);
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Num2Bits_2_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
cmp_index_ref_load = 0;
cmp_index_ref_load = 0;
// end load src
signalValues[mySignalStart + 0] = Fr_sub(1ull,ctx->signalValues[ctx->componentMemory[mySubcomponents[0]].signalStart + 252]);
for (uint i = 0; i < 1; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void LessEqThan_4_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 4;
ctx->componentMemory[coffset].templateName = "LessEqThan";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 2;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[1]{0};
}

void LessEqThan_4_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[2];
u64 lvar[1];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
// load src
// end load src
lvar[0] = 252ull;
{
std::string new_cmp_name = "lt";
LessThan_3_create(mySignalStart+3,0+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[0] = 0+ctx_index+1;
}
{
uint cmp_index_ref = 0;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = signalValues[mySignalStart + 1];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 0;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = Fr_add(signalValues[mySignalStart + 2],1ull);
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
LessThan_3_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
cmp_index_ref_load = 0;
cmp_index_ref_load = 0;
// end load src
signalValues[mySignalStart + 0] = ctx->signalValues[ctx->componentMemory[mySubcomponents[0]].signalStart + 0];
for (uint i = 0; i < 1; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void NOT_5_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 5;
ctx->componentMemory[coffset].templateName = "NOT";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 1;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[0];
}

void NOT_5_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[4];
u64 lvar[0];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
// load src
// end load src
signalValues[mySignalStart + 0] = Fr_sub(Fr_add(1ull,signalValues[mySignalStart + 1]),Fr_mul(2ull,signalValues[mySignalStart + 1]));
for (uint i = 0; i < 0; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void XOR_6_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 6;
ctx->componentMemory[coffset].templateName = "XOR";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 2;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[0];
}

void XOR_6_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[5];
u64 lvar[0];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
// load src
// end load src
signalValues[mySignalStart + 0] = Fr_sub(Fr_add(signalValues[mySignalStart + 1],signalValues[mySignalStart + 2]),Fr_mul(Fr_mul(2ull,signalValues[mySignalStart + 1]),signalValues[mySignalStart + 2]));
for (uint i = 0; i < 0; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void IsZero_7_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 7;
ctx->componentMemory[coffset].templateName = "IsZero";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 1;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[0];
}

void IsZero_7_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[3];
u64 lvar[0];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
if(Fr_isTrue(Fr_neq(signalValues[mySignalStart + 1],0ull))){
// load src
// end load src
signalValues[mySignalStart + 2] = Fr_div(1ull,signalValues[mySignalStart + 1]);
}else{
// load src
// end load src
signalValues[mySignalStart + 2] = 0ull;
}
// load src
// end load src
signalValues[mySignalStart + 0] = Fr_add(Fr_mul(Fr_neg(signalValues[mySignalStart + 1]),signalValues[mySignalStart + 2]),1ull);
{
if (!Fr_isTrue(Fr_eq(Fr_mul(signalValues[mySignalStart + 1],signalValues[mySignalStart + 0]),0ull))) std::cout << "Failed assert in template/function " << myTemplateName << " line 33. " <<  "Followed trace of components: " << ctx->getTrace(myId) << std::endl;
assert(Fr_isTrue(Fr_eq(Fr_mul(signalValues[mySignalStart + 1],signalValues[mySignalStart + 0]),0ull)));
}
for (uint i = 0; i < 0; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void IsEqual_8_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 8;
ctx->componentMemory[coffset].templateName = "IsEqual";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 2;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[1]{0};
}

void IsEqual_8_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[1];
u64 lvar[0];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
{
std::string new_cmp_name = "isz";
IsZero_7_create(mySignalStart+3,0+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[0] = 0+ctx_index+1;
}
{
uint cmp_index_ref = 0;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = Fr_sub(signalValues[mySignalStart + 2],signalValues[mySignalStart + 1]);
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
IsZero_7_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
cmp_index_ref_load = 0;
cmp_index_ref_load = 0;
// end load src
signalValues[mySignalStart + 0] = ctx->signalValues[ctx->componentMemory[mySubcomponents[0]].signalStart + 0];
for (uint i = 0; i < 1; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void GreaterThan_9_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 9;
ctx->componentMemory[coffset].templateName = "GreaterThan";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 2;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[1]{0};
}

void GreaterThan_9_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[1];
u64 lvar[1];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
// load src
// end load src
lvar[0] = 252ull;
{
std::string new_cmp_name = "lt";
LessThan_3_create(mySignalStart+3,0+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[0] = 0+ctx_index+1;
}
{
uint cmp_index_ref = 0;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = signalValues[mySignalStart + 2];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 0;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = signalValues[mySignalStart + 1];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
LessThan_3_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
cmp_index_ref_load = 0;
cmp_index_ref_load = 0;
// end load src
signalValues[mySignalStart + 0] = ctx->signalValues[ctx->componentMemory[mySubcomponents[0]].signalStart + 0];
for (uint i = 0; i < 1; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void OR_10_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 10;
ctx->componentMemory[coffset].templateName = "OR";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 2;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[0];
}

void OR_10_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[3];
u64 lvar[0];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
// load src
// end load src
signalValues[mySignalStart + 0] = Fr_sub(Fr_add(signalValues[mySignalStart + 1],signalValues[mySignalStart + 2]),Fr_mul(signalValues[mySignalStart + 1],signalValues[mySignalStart + 2]));
for (uint i = 0; i < 0; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void AND_11_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 11;
ctx->componentMemory[coffset].templateName = "AND";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 2;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[0];
}

void AND_11_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[1];
u64 lvar[0];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
// load src
// end load src
signalValues[mySignalStart + 0] = Fr_mul(signalValues[mySignalStart + 1],signalValues[mySignalStart + 2]);
for (uint i = 0; i < 0; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void main_template_12_create(uint soffset,uint coffset,Circom_CalcWit* ctx,std::string componentName,uint componentFather){
ctx->componentMemory[coffset].templateId = 12;
ctx->componentMemory[coffset].templateName = "main_template";
ctx->componentMemory[coffset].signalStart = soffset;
ctx->componentMemory[coffset].inputCounter = 2;
ctx->componentMemory[coffset].componentName = componentName;
ctx->componentMemory[coffset].idFather = componentFather;
ctx->componentMemory[coffset].subcomponents = new uint[28]{0};
}

void main_template_12_run(uint ctx_index,Circom_CalcWit* ctx){
u64* signalValues = ctx->signalValues;
u64 expaux[1];
u64 lvar[0];
u64 mySignalStart = ctx->componentMemory[ctx_index].signalStart;
std::string myTemplateName = ctx->componentMemory[ctx_index].templateName;
std::string myComponentName = ctx->componentMemory[ctx_index].componentName;
u64 myFather = ctx->componentMemory[ctx_index].idFather;
u64 myId = ctx_index;
u32* mySubcomponents = ctx->componentMemory[ctx_index].subcomponents;
bool* mySubcomponentsParallel = ctx->componentMemory[ctx_index].subcomponentsParallel;
std::string* listOfTemplateMessages = ctx->listOfTemplateMessages;
uint sub_component_aux;
uint index_multiple_eq;
int cmp_index_ref_load = -1;
{
std::string new_cmp_name = "comp_0";
Mux1_1_create(mySignalStart+13,0+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[0] = 0+ctx_index+1;
}
{
std::string new_cmp_name = "comp_2";
LessEqThan_4_create(mySignalStart+316,15+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[1] = 15+ctx_index+1;
}
{
std::string new_cmp_name = "comp_3";
Mux1_1_create(mySignalStart+630,32+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[2] = 32+ctx_index+1;
}
{
std::string new_cmp_name = "comp_4";
NOT_5_create(mySignalStart+924,44+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[3] = 44+ctx_index+1;
}
{
std::string new_cmp_name = "comp_5";
NOT_5_create(mySignalStart+926,45+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[4] = 45+ctx_index+1;
}
{
std::string new_cmp_name = "comp_6";
XOR_6_create(mySignalStart+928,46+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[5] = 46+ctx_index+1;
}
{
std::string new_cmp_name = "comp_7";
Mux1_1_create(mySignalStart+931,47+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[6] = 47+ctx_index+1;
}
{
std::string new_cmp_name = "comp_10";
IsEqual_8_create(mySignalStart+21,2+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[7] = 2+ctx_index+1;
}
{
std::string new_cmp_name = "comp_11";
NOT_5_create(mySignalStart+27,4+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[8] = 4+ctx_index+1;
}
{
std::string new_cmp_name = "comp_12";
Mux1_1_create(mySignalStart+29,5+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[9] = 5+ctx_index+1;
}
{
std::string new_cmp_name = "comp_13";
Mux1_1_create(mySignalStart+37,7+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[10] = 7+ctx_index+1;
}
{
std::string new_cmp_name = "comp_16";
GreaterThan_9_create(mySignalStart+45,9+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[11] = 9+ctx_index+1;
}
{
std::string new_cmp_name = "comp_17";
OR_10_create(mySignalStart+305,12+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[12] = 12+ctx_index+1;
}
{
std::string new_cmp_name = "comp_19";
Mux1_1_create(mySignalStart+308,13+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[13] = 13+ctx_index+1;
}
{
std::string new_cmp_name = "comp_20";
XOR_6_create(mySignalStart+576,18+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[14] = 18+ctx_index+1;
}
{
std::string new_cmp_name = "comp_22";
Mux1_1_create(mySignalStart+579,19+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[15] = 19+ctx_index+1;
}
{
std::string new_cmp_name = "comp_23";
Mux1_1_create(mySignalStart+587,21+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[16] = 21+ctx_index+1;
}
{
std::string new_cmp_name = "comp_24";
Mux1_1_create(mySignalStart+595,23+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[17] = 23+ctx_index+1;
}
{
std::string new_cmp_name = "comp_25";
AND_11_create(mySignalStart+603,25+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[18] = 25+ctx_index+1;
}
{
std::string new_cmp_name = "comp_26";
Mux1_1_create(mySignalStart+606,26+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[19] = 26+ctx_index+1;
}
{
std::string new_cmp_name = "comp_27";
Mux1_1_create(mySignalStart+614,28+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[20] = 28+ctx_index+1;
}
{
std::string new_cmp_name = "comp_28";
Mux1_1_create(mySignalStart+622,30+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[21] = 30+ctx_index+1;
}
{
std::string new_cmp_name = "comp_31";
LessThan_3_create(mySignalStart+638,34+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[22] = 34+ctx_index+1;
}
{
std::string new_cmp_name = "comp_32";
AND_11_create(mySignalStart+895,36+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[23] = 36+ctx_index+1;
}
{
std::string new_cmp_name = "comp_33";
NOT_5_create(mySignalStart+898,37+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[24] = 37+ctx_index+1;
}
{
std::string new_cmp_name = "comp_34";
Mux1_1_create(mySignalStart+900,38+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[25] = 38+ctx_index+1;
}
{
std::string new_cmp_name = "comp_35";
Mux1_1_create(mySignalStart+908,40+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[26] = 40+ctx_index+1;
}
{
std::string new_cmp_name = "comp_36";
Mux1_1_create(mySignalStart+916,42+ctx_index+1,ctx,new_cmp_name,myId);
mySubcomponents[27] = 42+ctx_index+1;
}
{
uint cmp_index_ref = 0;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = 0ull;
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 0;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = 1ull;
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 0;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = 1ull;
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
// end load src
signalValues[mySignalStart + 4] = 6822900150086823476ull;
{
uint cmp_index_ref = 1;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = signalValues[mySignalStart + 2];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 1;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = signalValues[mySignalStart + 4];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
LessEqThan_4_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 2;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = 0ull;
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 2;
// load src
cmp_index_ref_load = 1;
cmp_index_ref_load = 1;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = ctx->signalValues[ctx->componentMemory[mySubcomponents[1]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 2;
// load src
cmp_index_ref_load = 0;
cmp_index_ref_load = 0;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = ctx->signalValues[ctx->componentMemory[mySubcomponents[0]].signalStart + 0];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 3;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = 1ull;
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
NOT_5_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 4;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = 1ull;
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
NOT_5_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 5;
// load src
cmp_index_ref_load = 3;
cmp_index_ref_load = 3;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = ctx->signalValues[ctx->componentMemory[mySubcomponents[3]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 5;
// load src
cmp_index_ref_load = 4;
cmp_index_ref_load = 4;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = ctx->signalValues[ctx->componentMemory[mySubcomponents[4]].signalStart + 0];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
XOR_6_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 6;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = 1ull;
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 6;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = 1ull;
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 6;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = 1ull;
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
// end load src
signalValues[mySignalStart + 5] = 14548162474639577817ull;
// load src
// end load src
signalValues[mySignalStart + 6] = 12983281506709331475ull;
{
uint cmp_index_ref = 7;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = signalValues[mySignalStart + 5];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 7;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = signalValues[mySignalStart + 6];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
IsEqual_8_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 8;
// load src
cmp_index_ref_load = 7;
cmp_index_ref_load = 7;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = ctx->signalValues[ctx->componentMemory[mySubcomponents[7]].signalStart + 0];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
NOT_5_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 9;
// load src
cmp_index_ref_load = 8;
cmp_index_ref_load = 8;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = ctx->signalValues[ctx->componentMemory[mySubcomponents[8]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 9;
// load src
cmp_index_ref_load = 6;
cmp_index_ref_load = 6;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = ctx->signalValues[ctx->componentMemory[mySubcomponents[6]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 9;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = 1ull;
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 10;
// load src
cmp_index_ref_load = 9;
cmp_index_ref_load = 9;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = ctx->signalValues[ctx->componentMemory[mySubcomponents[9]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 10;
// load src
cmp_index_ref_load = 5;
cmp_index_ref_load = 5;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = ctx->signalValues[ctx->componentMemory[mySubcomponents[5]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 10;
// load src
cmp_index_ref_load = 2;
cmp_index_ref_load = 2;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = ctx->signalValues[ctx->componentMemory[mySubcomponents[2]].signalStart + 0];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
// end load src
signalValues[mySignalStart + 7] = Fr_band(signalValues[mySignalStart + 2],signalValues[mySignalStart + 3]);
// load src
// end load src
signalValues[mySignalStart + 8] = Fr_bnot(signalValues[mySignalStart + 2]);
{
uint cmp_index_ref = 11;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = signalValues[mySignalStart + 7];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 11;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = signalValues[mySignalStart + 8];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
GreaterThan_9_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 12;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = 0ull;
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 12;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = 1ull;
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
OR_10_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
// end load src
signalValues[mySignalStart + 9] = Fr_bnot(signalValues[mySignalStart + 2]);
{
uint cmp_index_ref = 13;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = 15969839135450377938ull;
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 13;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = signalValues[mySignalStart + 9];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 13;
// load src
cmp_index_ref_load = 12;
cmp_index_ref_load = 12;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = ctx->signalValues[ctx->componentMemory[mySubcomponents[12]].signalStart + 0];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 14;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = 1ull;
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 14;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = 1ull;
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
XOR_6_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
// end load src
signalValues[mySignalStart + 10] = 10557910790515554005ull;
{
uint cmp_index_ref = 15;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = signalValues[mySignalStart + 2];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 15;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = signalValues[mySignalStart + 10];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 15;
// load src
cmp_index_ref_load = 14;
cmp_index_ref_load = 14;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = ctx->signalValues[ctx->componentMemory[mySubcomponents[14]].signalStart + 0];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 16;
// load src
cmp_index_ref_load = 15;
cmp_index_ref_load = 15;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = ctx->signalValues[ctx->componentMemory[mySubcomponents[15]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 16;
// load src
cmp_index_ref_load = 13;
cmp_index_ref_load = 13;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = ctx->signalValues[ctx->componentMemory[mySubcomponents[13]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 16;
// load src
cmp_index_ref_load = 11;
cmp_index_ref_load = 11;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = ctx->signalValues[ctx->componentMemory[mySubcomponents[11]].signalStart + 0];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 17;
// load src
cmp_index_ref_load = 16;
cmp_index_ref_load = 16;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = ctx->signalValues[ctx->componentMemory[mySubcomponents[16]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 17;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = 15634063055389091909ull;
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 17;
// load src
cmp_index_ref_load = 10;
cmp_index_ref_load = 10;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = ctx->signalValues[ctx->componentMemory[mySubcomponents[10]].signalStart + 0];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
cmp_index_ref_load = 17;
cmp_index_ref_load = 17;
// end load src
signalValues[mySignalStart + 0] = ctx->signalValues[ctx->componentMemory[mySubcomponents[17]].signalStart + 0];
{
uint cmp_index_ref = 18;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = 1ull;
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 18;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = 0ull;
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
AND_11_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 19;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = signalValues[mySignalStart + 3];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 19;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = signalValues[mySignalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 19;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = 1ull;
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 20;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = signalValues[mySignalStart + 2];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 20;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = 1ull;
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 20;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = 0ull;
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 21;
// load src
cmp_index_ref_load = 20;
cmp_index_ref_load = 20;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = ctx->signalValues[ctx->componentMemory[mySubcomponents[20]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 21;
// load src
cmp_index_ref_load = 19;
cmp_index_ref_load = 19;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = ctx->signalValues[ctx->componentMemory[mySubcomponents[19]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 21;
// load src
cmp_index_ref_load = 18;
cmp_index_ref_load = 18;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = ctx->signalValues[ctx->componentMemory[mySubcomponents[18]].signalStart + 0];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
// end load src
signalValues[mySignalStart + 11] = Fr_bnot(signalValues[mySignalStart + 2]);
// load src
cmp_index_ref_load = 21;
cmp_index_ref_load = 21;
// end load src
signalValues[mySignalStart + 12] = ctx->signalValues[ctx->componentMemory[mySubcomponents[21]].signalStart + 0];
{
uint cmp_index_ref = 22;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = signalValues[mySignalStart + 12];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 22;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = signalValues[mySignalStart + 11];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
LessThan_3_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 23;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = 0ull;
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 23;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = 0ull;
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
AND_11_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 24;
// load src
cmp_index_ref_load = 23;
cmp_index_ref_load = 23;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = ctx->signalValues[ctx->componentMemory[mySubcomponents[23]].signalStart + 0];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
NOT_5_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 25;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = signalValues[mySignalStart + 2];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 25;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = signalValues[mySignalStart + 3];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 25;
// load src
cmp_index_ref_load = 24;
cmp_index_ref_load = 24;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = ctx->signalValues[ctx->componentMemory[mySubcomponents[24]].signalStart + 0];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 26;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = signalValues[mySignalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 26;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = Fr_neg(signalValues[mySignalStart + 0]);
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 26;
// load src
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = 0ull;
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
{
uint cmp_index_ref = 27;
// load src
cmp_index_ref_load = 26;
cmp_index_ref_load = 26;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 1] = ctx->signalValues[ctx->componentMemory[mySubcomponents[26]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 27;
// load src
cmp_index_ref_load = 25;
cmp_index_ref_load = 25;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 2] = ctx->signalValues[ctx->componentMemory[mySubcomponents[25]].signalStart + 0];
// no need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter > 0);
}
{
uint cmp_index_ref = 27;
// load src
cmp_index_ref_load = 22;
cmp_index_ref_load = 22;
// end load src
ctx->signalValues[ctx->componentMemory[mySubcomponents[cmp_index_ref]].signalStart + 3] = ctx->signalValues[ctx->componentMemory[mySubcomponents[22]].signalStart + 0];
// need to run sub component
ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter -= 1;
assert(!(ctx->componentMemory[mySubcomponents[cmp_index_ref]].inputCounter));
Mux1_1_run(mySubcomponents[cmp_index_ref],ctx);
}
// load src
cmp_index_ref_load = 27;
cmp_index_ref_load = 27;
// end load src
signalValues[mySignalStart + 1] = ctx->signalValues[ctx->componentMemory[mySubcomponents[27]].signalStart + 0];
{
printf("<@> out0 = ");
}
{
printf(" ");
}
{
char* temp = Fr_element2str(signalValues[mySignalStart + 0]);
printf("%s",temp);
delete [] temp;
}
{
printf("\n");
}
{
printf("<@> out1 = ");
}
{
printf(" ");
}
{
char* temp = Fr_element2str(signalValues[mySignalStart + 1]);
printf("%s",temp);
delete [] temp;
}
{
printf("\n");
}
for (uint i = 0; i < 28; i++){
uint index_subc = ctx->componentMemory[ctx_index].subcomponents[i];
if (index_subc != 0){
assert(!(ctx->componentMemory[index_subc].inputCounter));
release_memory_component(ctx,index_subc);
}
}
}

void run(Circom_CalcWit* ctx){
main_template_12_create(1,0,ctx,"main",0);
main_template_12_run(0,ctx);
}

